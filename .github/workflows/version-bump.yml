name: Version Bump

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      custom_version:
        description: 'Custom version (optional, overrides version_type)'
        required: false
        type: string

jobs:
  bump-version:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
    
    - name: Get current version and calculate new version
      id: version
      shell: powershell
      run: |
        # Read current version from manifest
        [xml]$manifest = Get-Content "source.extension.vsixmanifest"
        $currentVersion = $manifest.PackageManifest.Metadata.Identity.Version
        Write-Host "Current version: $currentVersion"
        
        if ("${{ inputs.custom_version }}" -ne "") {
            $newVersion = "${{ inputs.custom_version }}"
            Write-Host "Using custom version: $newVersion"
        } else {
            # Parse version
            $versionParts = $currentVersion.Split('.')
            $major = [int]$versionParts[0]
            $minor = [int]$versionParts[1]
            $patch = if ($versionParts.Length -gt 2) { [int]$versionParts[2] } else { 0 }
            
            # Bump version based on type
            switch ("${{ inputs.version_type }}") {
                "major" {
                    $major++
                    $minor = 0
                    $patch = 0
                }
                "minor" {
                    $minor++
                    $patch = 0
                }
                "patch" {
                    $patch++
                }
            }
            
            $newVersion = "$major.$minor.$patch"
            Write-Host "Calculated new version: $newVersion"
        }
        
        echo "current-version=$currentVersion" >> $env:GITHUB_OUTPUT
        echo "new-version=$newVersion" >> $env:GITHUB_OUTPUT
    
    - name: Update version in manifest
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        Write-Host "Updating VSIX manifest to version: $newVersion"
        
        # Backup original file
        Copy-Item "source.extension.vsixmanifest" "source.extension.vsixmanifest.backup"
        
        try {
            # Update source.extension.vsixmanifest
            [xml]$manifest = Get-Content "source.extension.vsixmanifest"
            
            # Verify we can access the version attribute
            $currentVersion = $manifest.PackageManifest.Metadata.Identity.Version
            Write-Host "Current manifest version: $currentVersion"
            
            # Update the version
            $manifest.PackageManifest.Metadata.Identity.Version = $newVersion
            
            # Save with proper formatting
            $manifest.Save((Resolve-Path "source.extension.vsixmanifest").Path)
            
            # Verify the update worked
            [xml]$verifyManifest = Get-Content "source.extension.vsixmanifest"
            $updatedVersion = $verifyManifest.PackageManifest.Metadata.Identity.Version
            
            if ($updatedVersion -eq $newVersion) {
                Write-Host "✅ VSIX manifest updated successfully: $currentVersion → $newVersion"
                Remove-Item "source.extension.vsixmanifest.backup" -ErrorAction SilentlyContinue
            } else {
                throw "Version verification failed. Expected: $newVersion, Got: $updatedVersion"
            }
            
        } catch {
            Write-Error "Failed to update VSIX manifest: $($_.Exception.Message)"
            # Restore backup
            if (Test-Path "source.extension.vsixmanifest.backup") {
                Copy-Item "source.extension.vsixmanifest.backup" "source.extension.vsixmanifest"
                Remove-Item "source.extension.vsixmanifest.backup"
                Write-Host "Restored original manifest from backup"
            }
            exit 1
        }
    
    - name: Update AssemblyInfo (if exists)
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $assemblyInfoPath = "Properties\AssemblyInfo.cs"
        
        if (Test-Path $assemblyInfoPath) {
            Write-Host "Updating AssemblyInfo.cs..."
            
            $content = Get-Content $assemblyInfoPath
            $content = $content -replace '\[assembly: AssemblyVersion\(".*?"\)\]', "[assembly: AssemblyVersion(`"$newVersion.0`")]"
            $content = $content -replace '\[assembly: AssemblyFileVersion\(".*?"\)\]', "[assembly: AssemblyFileVersion(`"$newVersion.0`")]"
            
            $content | Set-Content $assemblyInfoPath
            Write-Host "AssemblyInfo.cs updated"
        } else {
            Write-Host "AssemblyInfo.cs not found, skipping"
        }
    
    - name: Create version bump pull request
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $branchName = "version-bump-$newVersion"
        
        Write-Host "Creating version bump pull request..."
        
        # Create and switch to new branch
        git checkout -b $branchName
        
        # Add changes
        git add source.extension.vsixmanifest
        if (Test-Path "Properties\AssemblyInfo.cs") {
            git add "Properties\AssemblyInfo.cs"
        }
        
        # Check if there are changes to commit
        git diff --cached --quiet
        if ($LASTEXITCODE -ne 0) {
            # Commit changes
            $commitMessage = "Bump version to $newVersion"
            git commit -m $commitMessage
            git push origin $branchName
            
            # Store branch name for next step
            echo "BRANCH_NAME=$branchName" >> $env:GITHUB_ENV
            echo "HAS_CHANGES=true" >> $env:GITHUB_ENV
            Write-Host "Version changes committed to branch: $branchName"
        } else {
            echo "HAS_CHANGES=false" >> $env:GITHUB_ENV
            Write-Host "No changes to commit"
        }
    
    - name: Create pull request and auto-merge
      if: env.HAS_CHANGES == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $branchName = $env:BRANCH_NAME
        
        Write-Host "Creating pull request for version bump..."
        
        $prTitle = "🚀 Bump version to $newVersion"
        $prBody = @"
        ## Version Bump to $newVersion

        This is an automated version bump created by the version-bump workflow.

        ### Changes:
        - Updated ``source.extension.vsixmanifest`` version to $newVersion
        - Updated ``Properties\AssemblyInfo.cs`` (if present)

        ### Next Steps:
        After this PR is merged, a new release will be created and published to the marketplace.
        "@
                
        # Create pull request
        $prUrl = gh pr create --title $prTitle --body $prBody --base main --head $branchName
        Write-Host "Pull request created: $prUrl"
        
        # Enable auto-merge (requires admin permissions or branch protection settings)
        try {
            gh pr merge $branchName --auto --squash
            Write-Host "Auto-merge enabled for the pull request"
        } catch {
            Write-Host "Could not enable auto-merge. PR will need to be merged manually: $prUrl"
        }
        
        # Store PR URL for later steps
        echo "PR_URL=$prUrl" >> $env:GITHUB_ENV
    
    - name: Wait for PR merge and create tag
      if: env.HAS_CHANGES == 'true'
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $tagName = "v$newVersion"
        
        Write-Host "Waiting for PR to be merged before creating tag..."
        
        # Wait for PR to be merged (with timeout)
        $timeout = 300 # 5 minutes
        $elapsed = 0
        $interval = 10 # seconds
        
        do {
            Start-Sleep -Seconds $interval
            $elapsed += $interval
            
            # Check if main branch has our changes
            git fetch origin main
            git checkout main
            git pull origin main
            
            # Check if the version in manifest matches what we expect
            [xml]$manifest = Get-Content "source.extension.vsixmanifest"
            $currentVersion = $manifest.PackageManifest.Metadata.Identity.Version
            
            if ($currentVersion -eq $newVersion) {
                Write-Host "✅ PR has been merged! Current version: $currentVersion"
                break
            }
            
            Write-Host "⏳ Waiting for PR merge... Current version: $currentVersion (Expected: $newVersion)"
            
        } while ($elapsed -lt $timeout)
        
        if ($elapsed -ge $timeout) {
            Write-Warning "⚠️ Timeout waiting for PR merge. Creating tag anyway..."
        }
        
        # Create and push tag
        Write-Host "Creating tag: $tagName"
        git tag $tagName
        git push origin $tagName
        
        echo "TAG_NAME=$tagName" >> $env:GITHUB_ENV
    
    - name: Create release notes
      if: env.HAS_CHANGES == 'true'
      id: release-notes
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $currentVersion = "${{ steps.version.outputs.current-version }}"
        
        # Generate release notes from README.md with version-specific header
        if (-not (Test-Path "README.md")) {
            Write-Error "README.md not found!"
            exit 1
        }
        
        # Read README content
        $readmeContent = Get-Content "README.md" -Raw
        
        # Create release notes with version header and README content
        $releaseNotes = @"$readmeContent"@
        
        # Save to temporary file for the release
        $releaseNotes | Out-File -FilePath "release-notes.md" -Encoding UTF8
        
        # Also output for GitHub (escape newlines)  
        $escapedNotes = $releaseNotes -replace "`r`n", "%0A" -replace "`n", "%0A"
        echo "notes=$escapedNotes" >> $env:GITHUB_OUTPUT
    
    - name: Create GitHub Release
      if: env.HAS_CHANGES == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.TAG_NAME }}
        name: "MediatR Navigation Extension v${{ steps.version.outputs.new-version }}"
        body_path: release-notes.md
        draft: true
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Clean up temporary files
      if: always()
      shell: powershell
      run: |
        # Remove temporary files created during the workflow
        Remove-Item "release-notes.md" -ErrorAction SilentlyContinue
        Remove-Item "source.extension.vsixmanifest.backup" -ErrorAction SilentlyContinue
        Write-Host "Temporary files cleaned up"
