name: Version Bump

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      custom_version:
        description: 'Custom version (optional, overrides version_type)'
        required: false
        type: string

jobs:
  bump-version:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
    
    - name: Get current version and calculate new version
      id: version
      shell: powershell
      run: |
        # Read current version from manifest
        [xml]$manifest = Get-Content "source.extension.vsixmanifest"
        $currentVersion = $manifest.PackageManifest.Metadata.Identity.Version
        Write-Host "Current version: $currentVersion"
        
        if ("${{ inputs.custom_version }}" -ne "") {
            $newVersion = "${{ inputs.custom_version }}"
            Write-Host "Using custom version: $newVersion"
        } else {
            # Parse version
            $versionParts = $currentVersion.Split('.')
            $major = [int]$versionParts[0]
            $minor = [int]$versionParts[1]
            $patch = if ($versionParts.Length -gt 2) { [int]$versionParts[2] } else { 0 }
            
            # Bump version based on type
            switch ("${{ inputs.version_type }}") {
                "major" {
                    $major++
                    $minor = 0
                    $patch = 0
                }
                "minor" {
                    $minor++
                    $patch = 0
                }
                "patch" {
                    $patch++
                }
            }
            
            $newVersion = "$major.$minor.$patch"
            Write-Host "Calculated new version: $newVersion"
        }
        
        echo "current-version=$currentVersion" >> $env:GITHUB_OUTPUT
        echo "new-version=$newVersion" >> $env:GITHUB_OUTPUT
    
    - name: Update version in manifest
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        Write-Host "Updating VSIX manifest to version: $newVersion"
        
        # Backup original file
        Copy-Item "source.extension.vsixmanifest" "source.extension.vsixmanifest.backup"
        
        try {
            # Update source.extension.vsixmanifest
            [xml]$manifest = Get-Content "source.extension.vsixmanifest"
            
            # Verify we can access the version attribute
            $currentVersion = $manifest.PackageManifest.Metadata.Identity.Version
            Write-Host "Current manifest version: $currentVersion"
            
            # Update the version
            $manifest.PackageManifest.Metadata.Identity.Version = $newVersion
            
            # Save with proper formatting
            $manifest.Save((Resolve-Path "source.extension.vsixmanifest").Path)
            
            # Verify the update worked
            [xml]$verifyManifest = Get-Content "source.extension.vsixmanifest"
            $updatedVersion = $verifyManifest.PackageManifest.Metadata.Identity.Version
            
            if ($updatedVersion -eq $newVersion) {
                Write-Host "✅ VSIX manifest updated successfully: $currentVersion → $newVersion"
                Remove-Item "source.extension.vsixmanifest.backup" -ErrorAction SilentlyContinue
            } else {
                throw "Version verification failed. Expected: $newVersion, Got: $updatedVersion"
            }
            
        } catch {
            Write-Error "Failed to update VSIX manifest: $($_.Exception.Message)"
            # Restore backup
            if (Test-Path "source.extension.vsixmanifest.backup") {
                Copy-Item "source.extension.vsixmanifest.backup" "source.extension.vsixmanifest"
                Remove-Item "source.extension.vsixmanifest.backup"
                Write-Host "Restored original manifest from backup"
            }
            exit 1
        }
    
    - name: Update AssemblyInfo (if exists)
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $assemblyInfoPath = "Properties\AssemblyInfo.cs"
        
        if (Test-Path $assemblyInfoPath) {
            Write-Host "Updating AssemblyInfo.cs..."
            
            $content = Get-Content $assemblyInfoPath
            $content = $content -replace '\[assembly: AssemblyVersion\(".*?"\)\]', "[assembly: AssemblyVersion(`"$newVersion.0`")]"
            $content = $content -replace '\[assembly: AssemblyFileVersion\(".*?"\)\]', "[assembly: AssemblyFileVersion(`"$newVersion.0`")]"
            
            $content | Set-Content $assemblyInfoPath
            Write-Host "AssemblyInfo.cs updated"
        } else {
            Write-Host "AssemblyInfo.cs not found, skipping"
        }
    
    - name: Commit version changes
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        Write-Host "Committing version changes..."
        
        git add source.extension.vsixmanifest
        if (Test-Path "Properties\AssemblyInfo.cs") {
            git add "Properties\AssemblyInfo.cs"
        }
        
        $commitMessage = "Bump version to $newVersion"
        git diff --cached --quiet
        if ($LASTEXITCODE -ne 0) {
            git commit -m $commitMessage
            git push origin HEAD
            Write-Host "Version changes committed and pushed"
        } else {
            Write-Host "No changes to commit"
        }
    
    - name: Create and push tag
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $tagName = "v$newVersion"
        
        Write-Host "Creating tag: $tagName"
        git tag $tagName
        git push origin $tagName
        
        echo "TAG_NAME=$tagName" >> $env:GITHUB_ENV
      shell: powershell
    
    - name: Create release notes
      id: release-notes
      shell: powershell
      run: |
        $newVersion = "${{ steps.version.outputs.new-version }}"
        $currentVersion = "${{ steps.version.outputs.current-version }}"
        
        # Generate release notes from README.md with version-specific header
        if (-not (Test-Path "README.md")) {
            Write-Error "README.md not found!"
            exit 1
        }
        
        # Read README content
        $readmeContent = Get-Content "README.md" -Raw
        
        # Create release notes with version header and README content
        $releaseNotes = @"$readmeContent"@
        
        # Save to temporary file for the release
        $releaseNotes | Out-File -FilePath "release-notes.md" -Encoding UTF8
        
        # Also output for GitHub (escape newlines)  
        $escapedNotes = $releaseNotes -replace "`r`n", "%0A" -replace "`n", "%0A"
        echo "notes=$escapedNotes" >> $env:GITHUB_OUTPUT
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.TAG_NAME }}
        name: "MediatR Navigation Extension v${{ steps.version.outputs.new-version }}"
        body_path: release-notes.md
        draft: true
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Clean up temporary files
      shell: powershell
      run: |
        # Remove temporary files created during the workflow
        Remove-Item "release-notes.md" -ErrorAction SilentlyContinue
        Remove-Item "source.extension.vsixmanifest.backup" -ErrorAction SilentlyContinue
        Write-Host "Temporary files cleaned up"
